#!/usr/bin/env bash
#
# jellysync - Sync files from SSH server to local directories
# Copyright (C) 2024 pschmitt
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

VERSION="1.0.0"

# Determine config file path
if [[ -n "${JELLYSYNC_CONFIG:-}" ]]
then
  CONFIG_FILE="$JELLYSYNC_CONFIG"
elif [[ -f "./jellysync.yaml" ]]
then
  CONFIG_FILE="./jellysync.yaml"
elif [[ -f "$HOME/.config/jellysync/config.yaml" ]]
then
  CONFIG_FILE="$HOME/.config/jellysync/config.yaml"
else
  CONFIG_FILE="./jellysync.yaml"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
declare -gA REMOTE=()
declare -gA LOCAL=()
declare -gA REMOTE_DIRS=()
declare -gA LOCAL_DIRS=()
declare -gA LIBRARY=()
declare -ga JOBS=()
declare -ga RSYNC_OPTS=()
DRY_RUN=
VERBOSE=

usage() {
  cat <<EOF
jellysync - Sync files from SSH server to local directories

Usage: ${0##*/} [OPTIONS] [JOB_NAME...]

Options:
  -c, --config FILE   Config file path (default: jellysync.yaml)
  -n, --dry-run       Perform a dry run (no actual sync)
  -v, --verbose       Verbose output
  -l, --list          List all jobs
  -h, --help          Show this help
  --version           Show version

Arguments:
  JOB_NAME           Sync specific job(s). If omitted, sync all jobs.

Examples:
  ${0##*/}                    # Sync all jobs
  ${0##*/} pluribus           # Sync only 'pluribus' job
  ${0##*/} -n "Star Trek"     # Dry run for 'Star Trek' job
  ${0##*/} -v pluribus movies # Sync multiple jobs with verbose output

Config file: ${CONFIG_FILE}
EOF
}

log() {
  echo -e "${BLUE}[jellysync]${NC} $*"
}

log_success() {
  echo -e "${GREEN}[✓]${NC} $*"
}

log_error() {
  echo -e "${RED}[✗]${NC} $*" >&2
}

log_warning() {
  echo -e "${YELLOW}[!]${NC} $*"
}



check_dependencies() {
  local missing=()

  if ! command -v yq &>/dev/null
  then
    missing+=(yq)
  fi

  if ! command -v rsync &>/dev/null
  then
    missing+=(rsync)
  fi

  if ! command -v ssh &>/dev/null
  then
    missing+=(ssh)
  fi

  if [[ ${#missing[@]} -gt 0 ]]
  then
    log_error "Missing required commands: ${missing[*]}"
    return 1
  fi
}

# Load config using yq (Go version)
load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]
  then
    log_error "Config file not found: $CONFIG_FILE"
    return 1
  fi

  # Parse remote section
  if ! REMOTE[hostname]=$(yq '.remote.hostname' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse remote.hostname from config"
    return 1
  fi

  if ! REMOTE[username]=$(yq '.remote.username' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse remote.username from config"
    return 1
  fi

  if ! REMOTE[port]=$(yq '.remote.port // 22' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse remote.port from config"
    return 1
  fi

  if ! REMOTE[root]=$(yq '.remote.root' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse remote.root from config"
    return 1
  fi

  # Parse local section
  if ! LOCAL[root]=$(yq '.local.root' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse local.root from config"
    return 1
  fi

  # Parse remote directories
  local remote_dir_keys
  remote_dir_keys=$(yq '.remote.directories | keys | .[]' "$CONFIG_FILE" 2>/dev/null)
  if [[ -n "$remote_dir_keys" ]]
  then
    while IFS= read -r key
    do
      if [[ -n "$key" ]]
      then
        if ! REMOTE_DIRS[$key]=$(yq ".remote.directories.${key}" "$CONFIG_FILE" 2>/dev/null)
        then
          log_warning "Failed to parse remote directory: $key"
        fi
      fi
    done <<< "$remote_dir_keys"
  fi

  # Parse local directories
  local local_dir_keys
  local_dir_keys=$(yq '.local.directories | keys | .[]' "$CONFIG_FILE" 2>/dev/null)
  if [[ -n "$local_dir_keys" ]]
  then
    while IFS= read -r key
    do
      if [[ -n "$key" ]]
      then
        if ! LOCAL_DIRS[$key]=$(yq ".local.directories.${key}" "$CONFIG_FILE" 2>/dev/null)
        then
          log_warning "Failed to parse local directory: $key"
        fi
      fi
    done <<< "$local_dir_keys"
  fi

  # Parse library settings
  # shellcheck disable=SC2016
  LIBRARY[season_pattern]=$(yq '.library.season_pattern // "Season $season_number"' "$CONFIG_FILE" 2>/dev/null)

  # Parse jobs
  local job_count
  local i
  local job_name
  local remote_dir
  local local_dir
  local directory
  local wildcard
  local job_data
  if ! job_count=$(yq '.jobs | length' "$CONFIG_FILE" 2>/dev/null)
  then
    log_error "Failed to parse jobs from config"
    return 1
  fi

  for ((i=0; i<job_count; i++))
  do
    if ! job_name=$(yq ".jobs[$i].name" "$CONFIG_FILE" 2>/dev/null)
    then
      log_warning "Failed to parse job name at index $i"
      continue
    fi

    remote_dir=$(yq ".jobs[$i].remote_dir // \"\"" "$CONFIG_FILE" 2>/dev/null)
    local_dir=$(yq ".jobs[$i].local_dir // \"\"" "$CONFIG_FILE" 2>/dev/null)
    directory=$(yq ".jobs[$i].directory // \"\"" "$CONFIG_FILE" 2>/dev/null)
    seasons=$(yq ".jobs[$i].seasons // \"\"" "$CONFIG_FILE" 2>/dev/null)
    wildcard=$(yq ".jobs[$i].wildcard // false" "$CONFIG_FILE" 2>/dev/null)

    job_data="name=${job_name}"
    if [[ -n "$remote_dir" && "$remote_dir" != "null" ]]
    then
      job_data+="|remote_dir=${remote_dir}"
    fi

    if [[ -n "$local_dir" && "$local_dir" != "null" ]]
    then
      job_data+="|local_dir=${local_dir}"
    fi

    if [[ -n "$directory" && "$directory" != "null" ]]
    then
      job_data+="|directory=${directory}"
    fi

    if [[ -n "$seasons" && "$seasons" != "null" ]]
    then
      job_data+="|seasons=${seasons}"
    fi

    if [[ "$wildcard" == "true" ]]
    then
      job_data+="|wildcard=1"
    fi

    JOBS+=("$job_data")
  done

  # Validate required config
  if [[ -z "${REMOTE[hostname]:-}" || "${REMOTE[hostname]}" == "null" ]]
  then
    log_error "Missing remote.hostname in config"
    return 1
  fi

  if [[ -z "${REMOTE[username]:-}" || "${REMOTE[username]}" == "null" ]]
  then
    log_error "Missing remote.username in config"
    return 1
  fi

  if [[ -z "${REMOTE[root]:-}" || "${REMOTE[root]}" == "null" ]]
  then
    log_error "Missing remote.root in config"
    return 1
  fi

  if [[ -z "${LOCAL[root]:-}" || "${LOCAL[root]}" == "null" ]]
  then
    log_error "Missing local.root in config"
    return 1
  fi

  # Parse rsync options (optional)
  local rsync_flags
  rsync_flags=$(yq '.rsync.flags[]? // ""' "$CONFIG_FILE" 2>/dev/null)
  if [[ -n "$rsync_flags" ]]
  then
    while IFS= read -r flag
    do
      if [[ -n "$flag" ]]
      then
        RSYNC_OPTS+=("$flag")
      fi
    done <<< "$rsync_flags"
  fi

  # Use default rsync options if none specified
  if [[ ${#RSYNC_OPTS[@]} -eq 0 ]]
  then
    RSYNC_OPTS=(-a -v -z --delete)
  fi
}

# Expand path template with variables
# Usage: expand_path --remote|--local "$path" "$job_name"
expand_path() {
  local mode=""
  local target_path=""
  local job_name=""

  # Parse arguments
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      --remote)
        mode="remote"
        shift
        ;;
      --local)
        mode="local"
        shift
        ;;
      *)
        if [[ -z "$target_path" ]]
        then
          target_path="$1"
        else
          job_name="$1"
        fi
        shift
        ;;
    esac
  done

  # Replace $name with job name
  target_path="${target_path//\$name/$job_name}"

  # Replace directory variables (e.g., $tv_shows, $movies)
  local dir_var
  for dir_var in "${!REMOTE_DIRS[@]}"
  do
    if [[ "$mode" == "remote" ]]
    then
      target_path="${target_path//\$$dir_var/${REMOTE_DIRS[$dir_var]}}"
    else
      target_path="${target_path//\$$dir_var/${LOCAL_DIRS[$dir_var]}}"
    fi
  done

  echo "$target_path"
}

# Expand tilde and $HOME in path
expand_home() {
  local path_str="$1"

  # Expand $HOME
  path_str="${path_str//\$HOME/$HOME}"

  # Expand ~ at the beginning
  if [[ "$path_str" =~ ^~ ]]
  then
    path_str="${path_str/#\~/$HOME}"
  fi

  echo "$path_str"
}

# Get full path (handle absolute vs relative)
get_full_path() {
  local base_root="$1"
  local rel_path="$2"

  # Expand ~ and $HOME first
  base_root=$(expand_home "$base_root")
  rel_path=$(expand_home "$rel_path")

  if [[ "$rel_path" =~ ^/ ]]
  then
    # Absolute path
    echo "$rel_path"
  else
    # Relative path
    echo "${base_root%/}/${rel_path#/}"
  fi
}

# Resolve wildcard path on remote server
# Returns the first matching directory
resolve_remote_wildcard() {
  local remote_path="$1"
  local remote_host="${REMOTE[username]}@${REMOTE[hostname]}"
  local remote_port="${REMOTE[port]:-22}"

  # Check if path contains wildcard characters
  if [[ ! "$remote_path" =~ [\*\?] ]]
  then
    # No wildcard, return as-is
    echo "$remote_path"
    return 0
  fi

  # Extract directory and pattern
  local base_dir
  local pattern
  base_dir=$(dirname "$remote_path")
  pattern=$(basename "$remote_path")

  # List directories on remote that match the pattern
  local matches
  if ! matches=$(ssh -p "$remote_port" "$remote_host" "find '$base_dir' -maxdepth 1 -type d -name '$pattern' 2>/dev/null | sort")
  then
    log_error "Failed to resolve wildcard: $remote_path"
    return 1
  fi

  if [[ -z "$matches" ]]
  then
    log_error "No matches found for wildcard: $remote_path"
    return 1
  fi

  # Return first match
  local first_match
  first_match=$(echo "$matches" | head -1)

  if [[ -n "$VERBOSE" ]]
  then
    log "  Resolved wildcard '$remote_path' -> '$first_match'"
  fi

  echo "$first_match"
  return 0
}

# Build season pattern for finding directories
build_season_find_pattern() {
  local show_name="$1"
  local pattern="${LIBRARY[season_pattern]}"

  pattern="${pattern//\$name/$show_name}"
  pattern="${pattern//\$season_number/*}"

  echo "$pattern"
}

# Extract season number from directory name using pattern
extract_season_number() {
  local dir_name="$1"
  local show_name="$2"
  local pattern="${LIBRARY[season_pattern]}"
  local escaped_name="$show_name"

  # Escape special regex characters in show_name
  escaped_name="${escaped_name//\\/\\\\}"
  escaped_name="${escaped_name//./\\.}"
  escaped_name="${escaped_name//[/\\[}"
  escaped_name="${escaped_name//]/\\]}"
  escaped_name="${escaped_name//\*/\\*}"
  escaped_name="${escaped_name//^/\\^}"
  escaped_name="${escaped_name//$/\\$}"
  escaped_name="${escaped_name//(/\\(}"
  escaped_name="${escaped_name//)/\\)}"
  escaped_name="${escaped_name//+/\\+}"
  escaped_name="${escaped_name//?/\\?}"
  escaped_name="${escaped_name//\{/\\\{}"
  escaped_name="${escaped_name//|/\\|}"

  # Replace $name and $season_number in pattern to create regex
  pattern="${pattern//\$name/$escaped_name}"
  pattern="${pattern//\$season_number/([0-9]+)}"

  if [[ "$dir_name" =~ $pattern ]]
  then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi

  return 1
}

# Get season directories from remote server
get_remote_seasons() {
  local remote_full="$1"
  local show_name="$2"
  local remote_host="${REMOTE[username]}@${REMOTE[hostname]}"
  local remote_port="${REMOTE[port]:-22}"
  local find_pattern
  local seasons

  find_pattern=$(build_season_find_pattern "$show_name")

  if ! seasons=$(ssh -p "$remote_port" "$remote_host" "find '$remote_full' -maxdepth 1 -type d -name '$find_pattern' 2>/dev/null | sort -V" 2>/dev/null)
  then
    return 1
  fi

  echo "$seasons"
}

# Sync job with season filtering
sync_job_with_seasons() {
  local job_name="$1"
  local remote_full="$2"
  local local_full="$3"
  local seasons_spec="$4"
  local remote_host="${REMOTE[username]}@${REMOTE[hostname]}"
  local remote_port="${REMOTE[port]:-22}"
  local available_seasons
  local season_dirs
  local season_dir
  local season_num
  local include_patterns
  local rsync_opts

  log "Syncing job: ${GREEN}${job_name}${NC} (with season filter)"

  # Get available seasons from remote
  if ! available_seasons=$(get_remote_seasons "$remote_full" "$job_name")
  then
    log_error "Failed to get seasons from remote: $remote_full"
    return 1
  fi

  if [[ -z "$available_seasons" ]]
  then
    log_warning "No seasons found in: $remote_full"
    log_warning "Using pattern: $(build_season_find_pattern "$job_name")"
    return 1
  fi

  # Parse seasons specification
  # Check if it's a YAML array (starts with '[') - use verbatim
  if [[ "$seasons_spec" =~ ^\[ ]]
  then
    local season_list
    season_list=$(echo "$seasons_spec" | sed 's/[][]//g' | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    season_dirs=""

    while IFS= read -r season_num
    do
      if [[ -n "$season_num" ]]
      then
        while IFS= read -r season_dir
        do
          local extracted_num
          extracted_num=$(extract_season_number "$(basename "$season_dir")" "$job_name")
          if [[ "$extracted_num" == "$season_num" ]]
          then
            season_dirs+="${season_dir}"$'\n'
            break
          fi
        done <<< "$available_seasons"
      fi
    done <<< "$season_list"
  elif [[ "$seasons_spec" == "latest" ]]
  then
    season_dirs=$(echo "$available_seasons" | tail -1)
  elif [[ "$seasons_spec" =~ ^([0-9]+)-([0-9]+)$ ]]
  then
    local range_start="${BASH_REMATCH[1]}"
    local range_end="${BASH_REMATCH[2]}"
    season_dirs=""

    while IFS= read -r season_dir
    do
      if season_num=$(extract_season_number "$(basename "$season_dir")" "$job_name")
      then
        if [[ $season_num -ge $range_start && $season_num -le $range_end ]]
        then
          season_dirs+="${season_dir}"$'\n'
        fi
      fi
    done <<< "$available_seasons"
  else
    log_error "Invalid seasons specification: $seasons_spec"
    log_error "Valid formats: 'latest', '1-10', or [1, 2, 3]"
    return 1
  fi

  if [[ -z "$season_dirs" ]]
  then
    log_warning "No seasons matched specification: $seasons_spec"
    return 1
  fi

  # Build include patterns for rsync
  include_patterns=()
  while IFS= read -r season_dir
  do
    if [[ -n "$season_dir" ]]
    then
      local season_name
      season_name=$(basename "$season_dir")
      include_patterns+=(--include="$season_name/***")
    fi
  done <<< "$season_dirs"

  if [[ ${#include_patterns[@]} -eq 0 ]]
  then
    log_error "No valid season patterns generated"
    return 1
  fi

  # Ensure local directory exists
  if [[ -z "$DRY_RUN" ]]
  then
    if ! mkdir -p "$local_full"
    then
      log_error "Failed to create local directory: $local_full"
      return 1
    fi
  fi

  # Build rsync command with filtering
  rsync_opts=("${RSYNC_OPTS[@]}")
  rsync_opts+=(-e "ssh -p ${remote_port}")
  rsync_opts+=("${include_patterns[@]}")
  rsync_opts+=(--exclude='*')

  if [[ -n "$DRY_RUN" ]]
  then
    rsync_opts+=(--dry-run)
  fi

  if [[ -n "$VERBOSE" ]]
  then
    rsync_opts+=(-v)
  else
    rsync_opts+=(--info=progress2)
  fi

  # Log seasons being synced
  log "  Syncing seasons:"
  while IFS= read -r season_dir
  do
    if [[ -n "$season_dir" ]]
    then
      log "    - $(basename "$season_dir")"
    fi
  done <<< "$season_dirs"

  # Log rsync command
  log "  Executing: rsync ${rsync_opts[*]} ${remote_host}:${remote_full}/ ${local_full}/"

  # Execute rsync
  if rsync "${rsync_opts[@]}" "${remote_host}:${remote_full}/" "$local_full/"
  then
    log_success "Completed: ${job_name}"
    return 0
  else
    log_error "Failed: ${job_name}"
    return 1
  fi
}

# List all jobs
list_jobs() {
  log "Available jobs in ${CONFIG_FILE}:"
  echo

  local job_data
  local job_name
  local pairs
  local pair
  local key
  local value
  for job_data in "${JOBS[@]}"
  do
    job_name=""

    # Parse job data
    while IFS='|' read -ra pairs
    do
      for pair in "${pairs[@]}"
      do
        IFS='=' read -r key value <<< "$pair"
        if [[ "$key" == "name" ]]
        then
          job_name="$value"
          break
        fi
      done
    done <<< "$job_data"

    echo "  • $job_name"
  done

  echo
}

# Sync a single job
sync_job() {
  local job_data="$1"

  # Parse job configuration
  local job_name=""
  local remote_dir=""
  local local_dir=""
  local directory=""
  local seasons=""
  local wildcard=""
  local pairs
  local pair
  local key
  local value

  while IFS='|' read -ra pairs
  do
    for pair in "${pairs[@]}"
    do
      IFS='=' read -r key value <<< "$pair"
      case "$key" in
        name)
          job_name="$value"
          ;;
        remote_dir)
          remote_dir="$value"
          ;;
        local_dir)
          local_dir="$value"
          ;;
        directory)
          directory="$value"
          ;;
        seasons)
          seasons="$value"
          ;;
        wildcard)
          wildcard="$value"
          ;;
      esac
    done
  done <<< "$job_data"

  if [[ -z "$job_name" ]]
  then
    return 1
  fi

  # Handle shorthand "directory" syntax
  if [[ -n "$directory" && -z "$remote_dir" && -z "$local_dir" ]]
  then
    remote_dir="\$$directory/\$name"
    local_dir="\$$directory/\$name"
  fi

  # Apply wildcard pattern if enabled
  if [[ -n "$wildcard" ]]
  then
    if [[ -z "$remote_dir" ]]
    then
      remote_dir="\$$directory/*\$name*"
    else
      # Wrap the $name variable with wildcards
      remote_dir="${remote_dir//\$name/*\$name*}"
    fi
  fi

  # Expand path templates
  remote_dir=$(expand_path --remote "$remote_dir" "$job_name")
  local_dir=$(expand_path --local "$local_dir" "$job_name")

  # Get full paths
  local remote_full
  local local_full
  remote_full=$(get_full_path "${REMOTE[root]}" "$remote_dir")

  # Resolve wildcards in remote path
  if [[ "$remote_full" =~ [\*\?] ]]
  then
    if ! remote_full=$(resolve_remote_wildcard "$remote_full")
    then
      log_error "Failed to resolve remote path: $remote_dir"
      return 1
    fi
  fi

  local_full=$(get_full_path "${LOCAL[root]}" "$local_dir")

  # Handle seasons filtering
  if [[ -n "$seasons" ]]
  then
    if ! sync_job_with_seasons "$job_name" "$remote_full" "$local_full" "$seasons"
    then
      return 1
    fi
    return 0
  fi

  # Build SSH/rsync command
  local remote_host="${REMOTE[username]}@${REMOTE[hostname]}"
  local remote_port="${REMOTE[port]:-22}"
  local remote_path="${remote_host}:${remote_full}/"

  log "Syncing job: ${GREEN}${job_name}${NC}"
  if [[ -n "$VERBOSE" ]]
  then
    log "  Remote: ${remote_path}"
    log "  Local:  ${local_full}/"
  fi

  # Ensure local directory exists
  if [[ -z "$DRY_RUN" ]]
  then
    if ! mkdir -p "$local_full"
    then
      log_error "Failed to create local directory: $local_full"
      return 1
    fi
  fi

  # Build rsync command
  local rsync_opts=("${RSYNC_OPTS[@]}")
  rsync_opts+=(-e "ssh -p ${remote_port}")

  if [[ -n "$DRY_RUN" ]]
  then
    rsync_opts+=(--dry-run)
  fi

  if [[ -n "$VERBOSE" ]]
  then
    rsync_opts+=(-v)
  else
    rsync_opts+=(--info=progress2)
  fi

  # Log rsync command
  log "  Executing: rsync ${rsync_opts[*]} ${remote_path} ${local_full}/"

  # Execute rsync
  if rsync "${rsync_opts[@]}" "$remote_path" "$local_full/"
  then
    log_success "Completed: ${job_name}"
    return 0
  else
    log_error "Failed: ${job_name}"
    return 1
  fi
}

# Main sync function
sync_jobs() {
  local target_jobs=("$@")

  local synced=0
  local failed=0

  local job_data
  local job_name
  local job_name_lower
  local pairs
  local pair
  local key
  local value
  local should_sync
  local target
  local target_lower
  for job_data in "${JOBS[@]}"
  do
    # Parse job name
    job_name=""
    while IFS='|' read -ra pairs
    do
      for pair in "${pairs[@]}"
      do
        IFS='=' read -r key value <<< "$pair"
        if [[ "$key" == "name" ]]
        then
          job_name="$value"
          break
        fi
      done
    done <<< "$job_data"

    # Skip if specific jobs requested and this isn't one
    if [[ ${#target_jobs[@]} -gt 0 ]]
    then
      should_sync=
      job_name_lower="${job_name,,}"
      for target in "${target_jobs[@]}"
      do
        target_lower="${target,,}"
        if [[ "$job_name_lower" == "$target_lower" ]]
        then
          should_sync=1
          break
        fi
      done

      if [[ -z "$should_sync" ]]
      then
        continue
      fi
    fi

    # Sync the job
    if sync_job "$job_data"
    then
      ((synced++))
    else
      ((failed++))
    fi

    echo
  done

  # Summary
  log "Summary: ${GREEN}${synced} succeeded${NC}, ${RED}${failed} failed${NC}"

  if [[ $failed -gt 0 ]]
  then
    return 1
  fi

  return 0
}

main() {
  local target_jobs=()

  # Parse command line arguments
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      -h|--help)
        usage
        return 0
        ;;
      --version)
        echo "jellysync v${VERSION}"
        return 0
        ;;
      -c|--config)
        CONFIG_FILE="$2"
        shift 2
        ;;
      -n|--dry-run)
        DRY_RUN=1
        shift
        ;;
      -v|--verbose)
        VERBOSE=1
        shift
        ;;
      -l|--list)
        if ! check_dependencies
        then
          return 1
        fi
        if ! load_config
        then
          return 1
        fi
        list_jobs
        return 0
        ;;
      -*)
        log_error "Unknown option: $1"
        return 2
        ;;
      *)
        target_jobs+=("$1")
        shift
        ;;
    esac
  done

  # Main execution
  if ! check_dependencies
  then
    return 1
  fi

  log "jellysync v${VERSION}"
  log "Config: ${CONFIG_FILE}"
  if [[ -n "$DRY_RUN" ]]
  then
    log_warning "DRY RUN MODE - No files will be synced"
  fi

  if ! load_config
  then
    return 1
  fi

  if ! sync_jobs "${target_jobs[@]}"
  then
    return 1
  fi

  return 0
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
